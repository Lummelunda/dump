<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Plain log (composer + indent folding)</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>

    <!-- Folding -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/fold/foldcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/fold/indent-fold.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/fold/foldgutter.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/fold/foldgutter.min.js"></script>

    <!-- In-editor Find -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/dialog/dialog.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/dialog/dialog.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/search/searchcursor.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/search/search.min.js"></script>

    <style>
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: #191e25;
        color: #a2acbb;
        overflow: hidden;
      }

      :root {
        --mono: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        --bg: #191e25;
        --text: #a2acbb;
        --muted: rgba(162, 172, 187, 0.7);
        --muted2: rgba(162, 172, 187, 0.38);
        --focusBg: rgba(0, 0, 0, 0.18);
        --stroke: rgba(162, 172, 187, 0.15);
      }

      .app {
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .topBar {
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
      }

      .composerRow {
        padding: 10px 18px 0 18px;
        display: flex;
        gap: 10px;
        align-items: flex-start;
      }

      .composerRow textarea {
        flex: 1;
        width: 100%;
        box-sizing: border-box;
        min-height: 0;
        height: calc(1.4em + 20px);
        resize: none;
        overflow: hidden;
        font: 14px/1.4 var(--mono);
        padding: 10px 12px;
        border: 0;
        outline: none;
        background: var(--focusBg);
        border-radius: 10px;
        color: var(--muted);
      }

      .composerRow textarea:focus {
        background: var(--focusBg);
      }

      .composerRow textarea::placeholder {
        color: var(--muted2);
      }

      .btn {
        font: 13px/1 var(--mono);
        padding: 10px 10px;
        border: 0;
        background: transparent;
        color: rgba(162, 172, 187, 0.75);
        cursor: pointer;
        border-radius: 8px;
        user-select: none;
      }
      .btn:hover {
        background: rgba(162, 172, 187, 0.08);
        color: rgba(162, 172, 187, 0.95);
      }

      .projectsBar {
        padding: 6px 30px 10px 30px;
        font: 13px/1.4 var(--mono);
        color: var(--muted2);
        user-select: none;
        white-space: nowrap;
        overflow-x: auto;
      }

      .projectsBar .label {
        color: var(--muted2);
        margin-right: 10px;
      }

      .projectLink {
        color: rgba(162, 172, 187, 0.75);
        cursor: pointer;
        margin-right: 14px;
      }

      .projectLink:hover {
        color: rgba(162, 172, 187, 0.95);
        text-decoration: underline;
        text-underline-offset: 3px;
      }

      .projectLink.active {
        color: rgba(162, 172, 187, 0.95);
        text-decoration: underline;
        text-underline-offset: 3px;
      }

      .editor {
        flex: 1;
        min-height: 0;
        position: relative;
      }

      .CodeMirror {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        height: 100% !important;
        font: 14px/1.4 var(--mono);
        padding: 8px 30px;
        background: var(--bg);
        color: var(--text);
        box-sizing: border-box;
      }

      .CodeMirror-cursor {
        border-left: 1.5px solid rgba(162, 172, 187, 0.35);
      }

      .CodeMirror-selected { background: rgba(162, 172, 187, 0.16) !important; }
      .CodeMirror-focused .CodeMirror-selected { background: rgba(162, 172, 187, 0.22) !important; }

      .CodeMirror-foldmarker { display: none !important; }

      .CodeMirror-gutters { background: transparent; border-right: none; }
      .CodeMirror-foldgutter { width: 12px; }
      .CodeMirror-foldgutter-open, .CodeMirror-foldgutter-folded { opacity: 0.35; }
      .CodeMirror-foldgutter-open:hover, .CodeMirror-foldgutter-folded:hover { opacity: 0.8; }

      .cm-dimline { opacity: 0.22; }

      .CodeMirror-dialog {
        background: var(--bg);
        color: var(--text);
        border-bottom: 1px solid var(--stroke);
        font: 14px/1.4 var(--mono);
      }
      .CodeMirror-dialog input {
        background: transparent;
        color: var(--text);
        border: 0;
        outline: none;
        font: 14px/1.4 var(--mono);
      }

      .cm-todo-line {
        cursor: pointer;
      }
      .cm-todo-line:hover {
        background: rgba(162, 172, 187, 0.08);
      }
    </style>
  </head>

  <body>
    <div class="app">
      <div class="topBar">
        <div class="composerRow">
          <textarea
            id="composer"
            placeholder="Write here…"
            spellcheck="false"
            autocapitalize="off"
            autocomplete="off"
            autocorrect="off"
          ></textarea>
          <button class="btn" id="todosBtn" title="Todos">[ ]</button>
          <button class="btn" id="helpBtn" title="Help">?</button>
        </div>
        <div class="projectsBar" id="projectsBar"></div>
      </div>

      <div class="editor">
        <textarea id="t"></textarea>
      </div>
    </div>

    <script>
      const STORAGE_KEY = "plain_log_v1";
      const SAVE_DEBOUNCE_MS = 600;

      const HELP_TEXT = [
        "Help",
        "",
        "Capture",
        "  Cmd+K         Focus composer",
        "  Cmd+Enter     Prepend text exactly as written",
        "",
        "Folding (indent-based)",
        "  Tab           Indent",
        "  Shift+Tab     Outdent",
        "  Cmd+Enter     Unfold/fold if line has children, else toggle todo or fold",
        "  Shift+Enter   Smart task: empty→- [ ], todo↔toggle, text→- [ ] text, parent↔fold (keeps indent!)",
        "",
        "Find",
        "  Cmd+F         Find",
        "  Cmd+G         Next",
        "  Shift+Cmd+G   Previous",
        "",
        "Todos",
        "  [ ] button    View all uncompleted todos (clean list only)",
        "  Click a todo  Jump to it",
        "",
        "Links",
        "  Cmd+Click     Open URL under cursor",
        "  Cmd+Shift+Click Open URL at cursor",
        "  Cmd+Shift+Enter Shorten URL at cursor (is.gd)",
        "",
        "Backup",
        "  Cmd+S         Export journal-YYYY-MM-DD.txt",
        "",
        "Notes",
        "  Press Escape to exit help/projects/todos.",
        ""
      ].join("\n");

      let helpMode = false;
      let todosMode = false;
      let displayLineToOriginal = [];
      let waitingForShortener = false;

      // ---- Editor ----
      const cm = CodeMirror.fromTextArea(document.getElementById("t"), {
        lineNumbers: false,
        mode: null,
        lineWrapping: true,
        indentWithTabs: true,
        indentUnit: 1,
        tabSize: 1,
        gutters: ["CodeMirror-foldgutter"],
        foldGutter: true,
        foldOptions: { rangeFinder: CodeMirror.fold.indent, clearOnEnter: false },
        viewportMargin: Infinity,

        extraKeys: {
          Tab: (cm) => cm.execCommand("insertTab"),
          "Shift-Tab": (cm) => cm.execCommand("indentLess"),
          "Cmd-F": "findPersistent",
          "Ctrl-F": "findPersistent",
          "Cmd-G": "findNext",
          "Shift-Cmd-G": "findPrev",

          "Cmd-Enter": (cm) => {
            const cur = cm.getCursor();
            const lineNum = cur.line;
            const line = cm.getLine(lineNum);

            const hasChildren = (() => {
              if (lineNum + 1 >= cm.lineCount()) return false;
              const nextLine = cm.getLine(lineNum + 1);
              const currIndent = (line.match(/^\t*/) || [""])[0].length;
              const nextIndent = (nextLine.match(/^\t*/) || [""])[0].length;
              return nextIndent > currIndent;
            })();

            if (hasChildren) {
              cm.foldCode(cur);
              return;
            }

            const isTodo = /^(\s*-\s\[( |x|X)\])(\s?.*)$/.test(line);
            if (isTodo) {
              const replaced = line.replace(/^(\s*-\s\[)( |x|X)(\])/, (m, a, state, c) => {
                const next = state.toLowerCase() === "x" ? " " : "x";
                return a + next + c;
              });
              cm.replaceRange(replaced, { line: lineNum, ch: 0 }, { line: lineNum, ch: line.length });
              return;
            }

            cm.foldCode(cur);
          },

          "Shift-Enter": (cm) => {
          const cur = cm.getCursor();
          const lineNum = cur.line;
          const line = cm.getLine(lineNum);
          const trimmedLine = line.trim();

          // Preserve original indentation
          const indentMatch = line.match(/^\t*/);
          const indent = indentMatch ? indentMatch[0] : "";

          // 1. Empty line → Create new unchecked task (clear whole line)
          if (!trimmedLine) {
            cm.replaceRange(indent + "- [ ] ", { line: lineNum, ch: 0 }, { line: lineNum, ch: line.length });
            return;
          }

          // 2. Existing todo → Toggle it
          const isTodo = /^(\s*-\s\[( |x|X)\])(\s?.*)$/.test(line);
          if (isTodo) {
            const replaced = line.replace(/^(\s*-\s\[)( |x|X)(\])/, (m, a, state, c) => {
              const next = state.toLowerCase() === "x" ? " " : "x";
              return a + next + c;
            });
            cm.replaceRange(replaced, { line: lineNum, ch: 0 }, { line: lineNum, ch: line.length });
            return;
          }

          // 3. Has children → Toggle fold
          const hasChildren = (() => {
            if (lineNum + 1 >= cm.lineCount()) return false;
            const nextLine = cm.getLine(lineNum + 1);
            const currIndent = (line.match(/^\t*/) || [""])[0].length;
            const nextIndent = (nextLine.match(/^\t*/) || [""])[0].length;
            return nextIndent > currIndent;
          })();
          if (hasChildren) {
            cm.foldCode(cur);
            return;
          }

          // 4. Plain text → Convert to task (preserving indent)
          cm.replaceRange(indent + "- [ ] " + trimmedLine, { line: lineNum, ch: 0 }, { line: lineNum, ch: line.length });
        },

        },
      });

      try {
        const inp = cm.getInputField();
        inp.setAttribute("spellcheck", "false");
        inp.setAttribute("autocapitalize", "off");
        inp.setAttribute("autocomplete", "off");
        inp.setAttribute("autocorrect", "off");
      } catch (e) {}

      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        cm.setValue(saved || "");
      } catch (e) {
        cm.setValue("");
      }

      setTimeout(() => {
        if (!helpMode && !todosMode) cm.execCommand("foldAll");
      }, 0);

      // ---- Autosave ----
      let saveTimer = null;
      function scheduleSave() {
        if (helpMode || todosMode) return;
        if (saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(() => {
          try { localStorage.setItem(STORAGE_KEY, cm.getValue()); } catch (e) {}
        }, SAVE_DEBOUNCE_MS);
      }
      cm.on("change", scheduleSave);
      window.addEventListener("beforeunload", () => {
        if (helpMode || todosMode) return;
        try { localStorage.setItem(STORAGE_KEY, cm.getValue()); } catch (e) {}
      });

      // ---- Cmd+Shift link open and shortener ----
      cm.getWrapperElement().addEventListener("keydown", (e) => {
        if (waitingForShortener || helpMode || todosMode) return;

        if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === "Enter") {
          e.preventDefault();
          waitingForShortener = true;

          const cur = cm.getCursor();
          const lineNum = cur.line;
          const line = cm.getLine(lineNum);

          // Match a URL or markdown-style link
          let urlMatch = line.match(/(?:https?:\/\/)?(?:www\.)?[^)\s]+/);
          if (!urlMatch) { waitingForShortener = false; return; }

          let url = urlMatch[0];
          const mdMatch = line.match(/\[.*?\]\((https?:\/\/.*)\)/);
          if (mdMatch) url = mdMatch[1];
          if (!url.startsWith("http")) url = "https://" + url;
          if (url.includes("is.gd/")) { waitingForShortener = false; return; }

          const f = "cb" + Date.now();
          window[f] = (d) => {
            let short = d.shorturl || "Error";
            // Strip protocol: https://is.gd/abc → is.gd/abc
            short = short.replace(/^https?:\/\//, '');
            const urlStart = line.indexOf(urlMatch[0]);
            const urlEnd = urlStart + urlMatch[0].length;
            const from = { line: lineNum, ch: urlStart };
            const to = { line: lineNum, ch: urlEnd };
            cm.replaceRange(short, from, to);
            cm.setCursor({ line: lineNum, ch: urlStart + short.length });
            delete window[f];
            waitingForShortener = false;
          };

          const s = document.createElement("script");
          s.src = `https://is.gd/create.php?format=json&callback=${f}&url=${encodeURIComponent(url)}`;
          document.head.appendChild(s);
        }
      });

      // ---- Combined Cmd+Click handlers ----
      const LINK_RE = /\b(?:(https?:\/\/)?(?:www\.)?)((?:[a-z0-9-]+\.)+[a-z]{2,})(?::\d{2,5})?(?:\/[^\s<>()\[\]{}"']*)?/ig;
      function stripTrailingPunct(s) { return s.replace(/[),.;:!?]+$/, ""); }

      cm.getWrapperElement().addEventListener("mousedown", (e) => {
        if (helpMode || todosMode) return;

        const pos = cm.coordsChar({ left: e.clientX, top: e.clientY });
        const line = cm.getLine(pos.line);
        if (!line) return;

        // Cmd+Shift+Click: open link at cursor position
        if ((e.metaKey || e.ctrlKey) && e.shiftKey) {
          const mdMatch = line.match(/\[.*?\]\((https?:\/\/.*)\)/);
          const urlMatch = line.match(/(?:https?:\/\/)?(?:www\.)?[^)\s]+/);
          let url = null;

          if (mdMatch) url = mdMatch[1];
          else if (urlMatch) url = urlMatch[0].startsWith("http") ? urlMatch[0] : "https://" + urlMatch[0];

          if (url) {
            window.open(url, "_blank", "noopener,noreferrer");
            e.preventDefault();
            return;
          }
        }

        // Cmd+Click: open link under cursor (no shift)
        if (!e.shiftKey && (e.metaKey || e.ctrlKey)) {
          LINK_RE.lastIndex = 0;
          let m;
          while ((m = LINK_RE.exec(line))) {
            const start = m.index;
            const end = start + m[0].length;
            if (pos.ch >= start && pos.ch <= end) {
              let url = stripTrailingPunct(m[0]);
              if (!/^https?:\/\//i.test(url)) url = "https://" + url;
              window.open(url, "_blank", "noopener,noreferrer");
              e.preventDefault();
              return;
            }
          }
        }

        // Todos mode click handling
        if (todosMode) {
          const displayLine = pos.line;
          const originalLine = displayLineToOriginal[displayLine];
          if (typeof originalLine === "number" && originalLine >= 0) {
            exitTodosMode();
            cm.setCursor({ line: originalLine, ch: 0 });
            cm.scrollIntoView({ line: originalLine, ch: 0 }, 100);
            try { cm.foldCode({ line: originalLine, ch: 0 }, null, "unfold"); } catch (e) {}
            cm.focus();
          }
          e.preventDefault();
          return;
        }
      });

      // ---- Composer: pure prepend, no todo logic ----
      const composer = document.getElementById("composer");

      function autoGrow(el) {
        el.style.height = "0px";
        const max = 220;
        el.style.height = Math.min(el.scrollHeight, max) + "px";
      }
      autoGrow(composer);
      composer.addEventListener("input", () => autoGrow(composer));

      function normaliseNewlines(s) {
        return s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      }

      function prependFromComposer() {
        const raw = composer.value.trim();
        if (!raw) return;

        const doc = cm.getDoc();
        const scroll = cm.getScrollInfo();
        const cursor = doc.getCursor();

        const clean = normaliseNewlines(raw);
        const toInsert = clean;

        doc.replaceRange(toInsert + "\n", { line: 0, ch: 0 });

        const addedLines = clean.split("\n").length;
        doc.setCursor({ line: cursor.line + addedLines, ch: cursor.ch });
        cm.scrollTo(scroll.left, scroll.top + cm.defaultTextHeight() * addedLines);
        cm.refresh();

        composer.value = "";
        autoGrow(composer);
        composer.focus();
      }

      composer.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && e.metaKey) {
          e.preventDefault();
          prependFromComposer();
        }
      });

      // ---- Export ----
      function exportTxt() {
        const text = (helpMode || todosMode) ? (localStorage.getItem(STORAGE_KEY) || "") : cm.getValue();
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const now = new Date();
        const filename = `journal-${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}.txt`;
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }

      // ---- Projects ----
      const projectsBar = document.getElementById("projectsBar");
      const PROJECT_RE = /^Project:\s+(.+?)\s*$/;

      let focus = { active: false, name: "", headerLine: -1, startLine: -1, endLine: -1 };

      function getProjectHeaders() {
        const out = [];
        const n = cm.lineCount();
        for (let i = 0; i < n; i++) {
          const m = PROJECT_RE.exec(cm.getLine(i));
          if (m) out.push({ name: m[1], line: i });
        }
        return out;
      }

      function getProjectRange(headerLine) {
        let end = headerLine;
        const n = cm.lineCount();
        for (let i = headerLine + 1; i < n; i++) {
          const line = cm.getLine(i);
          if (PROJECT_RE.test(line)) break;
          if (/^\t/.test(line)) end = i;
          else if (line.trim() !== "") break;
        }
        return { start: headerLine, end };
      }

      function clearDimming() {
        for (let i = 0; i < cm.lineCount(); i++) cm.removeLineClass(i, "wrap", "cm-dimline");
      }

      function applyFocusDimming(start, end) {
        for (let i = 0; i < cm.lineCount(); i++) {
          if (i < start || i > end) cm.addLineClass(i, "wrap", "cm-dimline");
        }
      }

      function setComposerEnabled(enabled) {
        composer.disabled = !enabled;
        composer.style.opacity = enabled ? "1" : "0.5";
        composer.style.pointerEvents = enabled ? "auto" : "none";
      }

      function enterProjectFocus(project) {
        focus = { active: true, name: project.name, headerLine: project.line };
        const range = getProjectRange(project.line);
        focus.startLine = range.start;
        focus.endLine = range.end;
        try { cm.foldCode({ line: focus.headerLine, ch: 0 }, null, "unfold"); } catch (e) {}
        clearDimming();
        applyFocusDimming(focus.startLine, focus.endLine);
        cm.scrollIntoView({ line: focus.headerLine, ch: 0 }, 80);
        const endLine = Math.min(focus.endLine, cm.lineCount() - 1);
        cm.setCursor({ line: endLine, ch: (cm.getLine(endLine) || "").length });
        cm.focus();
        setComposerEnabled(false);
        renderProjectsBar();
      }

      function exitProjectFocus(opts = { fold: true }) {
        if (!focus.active) return;
        const headerLine = focus.headerLine;
        focus = { active: false, name: "", headerLine: -1, startLine: -1, endLine: -1 };
        clearDimming();
        setComposerEnabled(true);
        renderProjectsBar();
        if (opts.fold && headerLine >= 0 && !helpMode && !todosMode) {
          try { cm.foldCode({ line: headerLine, ch: 0 }, null, "fold"); } catch (e) {}
        }
      }

      function renderProjectsBar() {
        const projects = getProjectHeaders();
        const frag = document.createDocumentFragment();
        const label = document.createElement("span");
        label.className = "label";
        label.textContent = "Projects:";
        frag.appendChild(label);

        if (!projects.length) {
          const empty = document.createElement("span");
          empty.textContent = "none yet (add a line like: Project: Ops)";
          frag.appendChild(empty);
        } else {
          projects.forEach(p => {
            const link = document.createElement("span");
            link.className = "projectLink" + (focus.active && focus.name === p.name ? " active" : "");
            link.textContent = p.name;
            link.addEventListener("click", () => {
              if (helpMode || todosMode) return;
              if (focus.active && focus.name === p.name) exitProjectFocus({ fold: true });
              else enterProjectFocus(p);
            });
            frag.appendChild(link);
          });
        }
        projectsBar.innerHTML = "";
        projectsBar.appendChild(frag);
      }

      function refreshFocusAfterEdit() {
        if (!focus.active || helpMode || todosMode) return;
        const header = getProjectHeaders().find(p => p.name === focus.name);
        if (!header) return exitProjectFocus({ fold: false });
        focus.headerLine = header.line;
        const range = getProjectRange(header.line);
        focus.startLine = range.start;
        focus.endLine = range.end;
        clearDimming();
        applyFocusDimming(focus.startLine, focus.endLine);
      }

      renderProjectsBar();
      cm.on("change", () => {
        if (helpMode || todosMode) return;
        renderProjectsBar();
        refreshFocusAfterEdit();
      });

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && focus.active && !helpMode && !todosMode) {
          e.preventDefault();
          exitProjectFocus({ fold: true });
        }
      });

      // ---- Todos Mode: clean list only ----
      const todosBtn = document.getElementById("todosBtn");
      let journalCacheForTodos = "";

      function getTodoLinesFromText(text) {
        const lines = (text || "").split("\n");
        const todos = [];
        lines.forEach((line, idx) => {
          if (/-\s\[\s\]/.test(line)) {
            const cleanText = line.replace(/^\t+/, '');
            todos.push({ text: cleanText, lineNum: idx });
          }
        });
        return todos;
      }

      function enterTodosMode() {
        if (todosMode) return;
        if (helpMode) toggleHelp(false);
        exitProjectFocus({ fold: false });
        journalCacheForTodos = cm.getValue();
        todosMode = true;

        const todos = getTodoLinesFromText(journalCacheForTodos);
        const lines = [];
        displayLineToOriginal = [];

        todos.forEach(t => {
          lines.push(t.text);
          displayLineToOriginal.push(t.lineNum);
        });

        cm.setValue(lines.join("\n"));
        cm.setCursor({ line: 0, ch: 0 });

        setTimeout(() => {
          for (let i = 0; i < displayLineToOriginal.length; i++) {
            if (displayLineToOriginal[i] >= 0) cm.addLineClass(i, "wrap", "cm-todo-line");
          }
        }, 0);

        cm.focus();
      }

      function exitTodosMode() {
        if (!todosMode) return;
        todosMode = false;
        displayLineToOriginal = [];
        cm.setValue(journalCacheForTodos);
        cm.focus();
        setTimeout(() => cm.execCommand("foldAll"), 0);
        renderProjectsBar();
      }

      todosBtn.addEventListener("click", () => {
        if (todosMode) exitTodosMode();
        else enterTodosMode();
      });

      // ---- Help Mode ----
      const helpBtn = document.getElementById("helpBtn");
      let journalCache = "";

      function toggleHelp(force) {
        const next = typeof force === "boolean" ? force : !helpMode;
        if (next === helpMode) return;

        if (next) {
          if (todosMode) exitTodosMode();
          exitProjectFocus({ fold: false });
          journalCache = cm.getValue();
          helpMode = true;
          cm.setValue(HELP_TEXT);
          cm.setCursor({ line: 0, ch: 0 });
          cm.focus();
        } else {
          helpMode = false;
          cm.setValue(journalCache);
          cm.focus();
          setTimeout(() => cm.execCommand("foldAll"), 0);
          renderProjectsBar();
        }
      }

      helpBtn.addEventListener("click", () => toggleHelp());

      // ---- Global shortcuts ----
      document.addEventListener("keydown", (e) => {
        if (e.metaKey && !e.shiftKey && !e.ctrlKey && !e.altKey) {
          if (e.key.toLowerCase() === "k") {
            e.preventDefault();
            if (!composer.disabled) { composer.focus(); composer.select(); }
          } else if (e.key.toLowerCase() === "s") {
            e.preventDefault();
            exportTxt();
          }
        }

        if (e.key === "Escape") {
          if (helpMode) toggleHelp(false);
          else if (todosMode) exitTodosMode();
        }
      });

      cm.getWrapperElement().addEventListener("keydown", (e) => {
        if (e.metaKey && e.key.toLowerCase() === "f") e.preventDefault();
      });
    </script>
  </body>
</html>
