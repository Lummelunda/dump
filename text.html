<!-- A small riff on this https://github.com/antonmedv/textarea -->

<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Textarea</title>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html {
    color-scheme: light dark;
    background-color: #fff;
    color: #161616;

    @media (prefers-color-scheme: dark) {
      background-color: #000;
      color: #fff;
    }
  }

  body {
    position: relative;
  }

  article {
    outline: none;
    padding: 18px max(18px, calc(50vw - 400px));
    width: 100%;
    min-height: 100vh;
    font: 18px / 1.5 system-ui;
    tab-size: 4;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    white-space: pre-wrap;
    text-wrap-style: pretty;
    overflow-wrap: break-word;
  }

  #share-link {
    position: fixed;
    top: 12px;
    left: 12px;
    font-size: 14px;
    text-decoration: underline;
    color: blue;
    z-index: 1000;
  }

  #short-link {
    position: fixed;
    top: 32px;
    left: 12px;
    font-size: 12px;
    text-decoration: underline;
    z-index: 1000;
    opacity: 0.9;
    word-break: break-all;
    cursor: pointer;
  }

  #short-link.stale {
    opacity: 0.5;
  }

  #short-link.copied {
    opacity: 0.3;
  }
</style>

<a id="share-link" href="#">Share</a>
<a id="short-link" href="#" target="_blank" hidden></a>

<article contenteditable="plaintext-only" spellcheck></article>

<script>
  const article = document.querySelector('article')
  article.addEventListener('input', debounce(500, save))
  addEventListener('DOMContentLoaded', load)
  addEventListener('hashchange', load)

  async function load() {
    try {
      if (location.hash !== '') await set(location.hash)
      else {
        await set(localStorage.getItem('hash') ?? '')
        if (article.textContent) history.replaceState({}, '', await get())
        article.focus()
      }
    } catch (e) {
      article.textContent = ''
      article.removeAttribute('style')
    }
    updateTitle()
  }

  async function save() {
    const hash = await get()
    if (location.hash !== hash) history.replaceState({}, '', hash)
    try { localStorage.setItem('hash', hash) } catch (e) {}
    updateTitle()
    markShortLinkStale()
  }

  async function set(hash) {
    const [content, style] = (await decompress(hash.slice(1))).split('\x00')
    article.textContent = content
    if (style) article.setAttribute('style', style)
  }

  async function get() {
    const style = article.getAttribute('style')
    const content = article.textContent + (style !== null ? '\x00' + style : '')
    return '#' + await compress(content)
  }

  function updateTitle() {
    const match = article.textContent.match(/^\n*#(.+)\n/)
    document.title = match?.[1] ?? 'Textarea'
  }

  async function compress(string) {
    const byteArray = new TextEncoder().encode(string)
    const stream = new CompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new Uint8Array(buffer)
      .toBase64()
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
  }

  async function decompress(b64) {
    const byteArray = Uint8Array.fromBase64(
      b64.replace(/-/g, '+').replace(/_/g, '/')
    )
    const stream = new DecompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  function debounce(ms, fn) {
    let timer
    return (...args) => {
      clearTimeout(timer)
      timer = setTimeout(() => fn(...args), ms)
    }
  }

  // ---------- SHARE LINK ----------
  const shareLink = document.getElementById('share-link')
  const shortLink = document.getElementById('short-link')

  let lastGeneratedHash = null

  function isGdJsonp(longUrl) {
    return new Promise((resolve, reject) => {
      const cbName = '__isgd_cb_' + Math.random().toString(36).slice(2)
      const timeoutMs = 10000

      const cleanup = (script) => {
        if (script && script.parentNode) script.parentNode.removeChild(script)
        try { delete window[cbName] } catch { window[cbName] = undefined }
      }

      const timer = setTimeout(() => {
        cleanup(script)
        reject(new Error('Timed out'))
      }, timeoutMs)

      window[cbName] = (data) => {
        clearTimeout(timer)
        cleanup(script)

        if (data && data.shorturl) return resolve(String(data.shorturl))
        if (data && data.errormessage) return reject(new Error(String(data.errormessage)))
        reject(new Error('Unexpected response'))
      }

      const src =
        'https://is.gd/create.php' +
        '?format=json' +
        '&callback=' + encodeURIComponent(cbName) +
        '&url=' + encodeURIComponent(longUrl)

      const script = document.createElement('script')
      script.src = src
      script.async = true
      script.onerror = () => {
        clearTimeout(timer)
        cleanup(script)
        reject(new Error('Network error'))
      }

      document.head.appendChild(script)
    })
  }

  function markShortLinkStale() {
    if (lastGeneratedHash === null) return
    shortLink.classList.toggle('stale', location.hash !== lastGeneratedHash)
  }

  shareLink.addEventListener('click', async (e) => {
    e.preventDefault()

    const longUrl = location.href
    shareLink.textContent = 'Shorteningâ€¦'

    try {
      const shortUrl = await isGdJsonp(longUrl)

      shortLink.hidden = false
      shortLink.href = shortUrl
      shortLink.target = '_blank'
      shortLink.rel = 'noopener noreferrer'
      shortLink.textContent = shortUrl

      lastGeneratedHash = location.hash
      markShortLinkStale()

      shareLink.textContent = 'Share'
    } catch (err) {
      shareLink.textContent = 'Share'
      console.error(err)
    }
  })

  // ---------- COPY SHORT LINK ----------
  shortLink.addEventListener('click', async (e) => {
    // Copy on plain click, allow normal open with modifier keys
    if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return

    e.preventDefault()

    try {
      await navigator.clipboard.writeText(shortLink.href)
      shortLink.classList.add('copied')
      setTimeout(() => shortLink.classList.remove('copied'), 300)
    } catch (err) {
      console.error('Clipboard failed', err)
    }
  })
</script>
